<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Review · Account {{ account }} · {{ date }}</title>
  <!-- Choices.js for in-dropdown searchable selects -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0ea5e9; --bg2:#4338ca; --glass:rgba(255,255,255,.72); --border:rgba(255,255,255,.33); --leftW:33vw; }
    body{font-family:Inter,system-ui,sans-serif;margin:0;background:linear-gradient(135deg,var(--bg),var(--bg2));min-height:100vh;color:#0f172a}
    header.top{position:sticky;top:0;display:flex;justify-content:space-between;align-items:center;padding:14px 20px;color:#fff;z-index:100}
    .logout form{display:inline}
    .btn{display:inline-block;padding:8px 12px;border-radius:10px;border:none;background:#0ea5e9;color:#fff;cursor:pointer;text-decoration:none}
    .btn.secondary{background:#64748b}
    .btn.small{padding:6px 10px;font-size:12px;border-radius:8px}
    .wrap{max-width:1600px;margin:20px auto;padding:0 24px}
    /* 1/3 vs 2/3 responsive with draggable divider */
    .row{display:grid;grid-template-columns:minmax(320px,var(--leftW)) 6px minmax(600px,1fr);gap:20px;align-items:start}
    .card{background:var(--glass);backdrop-filter:blur(10px);border:1px solid var(--border);border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:16px}
    h1{margin:0 0 12px 0;font-size:20px}
    iframe{width:100%;height:calc(100vh - 160px);border:1px solid #e5e7eb;border-radius:12px;background:#fff}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    /* label | readonly view | control */
    .field{display:grid;grid-template-columns:1fr 1.6fr minmax(200px, 340px);align-items:center;gap:10px}
    .lbl{font-size:12px;opacity:.8;text-align:center}
    input[type=text]{padding:8px;border-radius:10px;border:1px solid #e5e7eb}
    select{padding:8px;border-radius:10px;border:1px solid #e5e7eb;background:#fff}
    /* keep controls from spanning too wide */
    .field input[type=text], .field select{max-width:340px}
    /* Choices wrapper width */
    .choices{max-width:340px; font-size:14px}
    .choices__inner{min-height:auto;padding:6px 8px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;box-shadow:none}
    .choices.is-open .choices__inner{border-bottom-left-radius:10px;border-bottom-right-radius:10px}
    .choices__list--dropdown{max-height:260px;border:1px solid #e5e7eb;border-radius:10px;margin-top:4px;box-shadow:0 4px 14px rgba(0,0,0,.06);z-index:100}
    .choices.is-open{z-index:101}
    .choices__list--dropdown .choices__item{padding:6px 8px}
    .choices__item.is-highlighted{background:#f8fafc}
    .choices__placeholder{opacity:.7}
    .choices__input{padding:6px 8px}
    .bar{display:flex;gap:10px;justify-content:flex-end;margin-top:10px}
    /* removed duplicate secondary, consolidated above */
    .header{margin-bottom:12px}
    .lines{height:calc(100vh - 240px);overflow:auto;margin-top:8px}
    .line{padding:8px;border-radius:10px;border:1px solid #e5e7eb;background:#fff;margin-bottom:8px}
    .line:hover{background:#f8fafc}
    .line select{position:relative; z-index:3; pointer-events:auto}
    .muted{font-size:12px;opacity:.7}
    .section-title{font-size:16px;font-weight:600;margin:0 0 8px 0}
    .line-num{font-size:20px;font-weight:700;margin:4px 0 8px}
    .resizer{width:6px;background:rgba(255,255,255,.55);border-radius:6px;cursor:col-resize;user-select:none;align-self:stretch}
    .resizer:hover{background:rgba(255,255,255,.8)}
    .toast{position:fixed;right:20px;top:20px;z-index:9999;min-width:320px;max-width:520px;background:#fff;border-radius:12px;border:1px solid #e5e7eb;box-shadow:0 10px 30px rgba(0,0,0,.15);padding:12px 14px;display:none}
    .toast.show{display:block}
    .toast .title{font-weight:600;margin-bottom:6px}
    .toast .ok{color:#16a34a}
    .toast .err{color:#dc2626}
    .toolbar{display:flex;justify-content:flex-end;gap:10px;margin-bottom:8px}
    .searchbox{margin-bottom:6px}
    .searchbox input{width:100%;max-width:340px;padding:6px 8px;border-radius:8px;border:1px solid #e5e7eb}
    .line[data-minimized="1"] .field{display:none}
    .line[data-minimized="1"] .line-summary{display:block}
    .line-summary{display:none;font-size:13px;color:#64748b;margin-top:6px}
    .minimize-btn{font-size:11px;padding:4px 8px;border-radius:6px;border:1px solid #e5e7eb;background:#fff;cursor:pointer;margin-left:8px}
    .improve-modal-overlay{display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.5);z-index:10000;align-items:center;justify-content:center}
    .improve-modal-overlay.show{display:flex}
    .improve-modal-box{background:#fff;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.3);max-width:420px;width:90%;padding:24px}
    .improve-modal-box h2{margin:0 0 16px 0;font-size:18px}
    .improve-modal-box label{display:block;margin-bottom:4px;font-weight:600;font-size:13px}
    .improve-modal-box input,.improve-modal-box textarea{width:100%;padding:10px;border:1px solid #e5e7eb;border-radius:8px;margin-bottom:12px;font-family:inherit;font-size:14px}
    .improve-modal-box textarea{min-height:100px;resize:vertical}
    .improve-modal-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}
    .improve-toast{position:fixed;top:20px;right:20px;background:#111827;color:#fff;padding:12px 16px;border-radius:10px;box-shadow:0 8px 20px rgba(0,0,0,.25);z-index:10001;opacity:0;transition:opacity .3s}
    .improve-toast.show{opacity:.96}
    .improve-toast.ok{background:#0f766e}
    .improve-toast.err{background:#b91c1c}
    /* Line items total display */
    .line-items-total{position:sticky;bottom:0;background:rgba(255,255,255,0.95);backdrop-filter:blur(8px);padding:12px 16px;border-top:2px solid #0ea5e9;border-radius:0 0 10px 10px;margin-top:8px;display:flex;justify-content:space-between;align-items:center;font-size:16px;font-weight:600;box-shadow:0 -4px 12px rgba(0,0,0,0.08);z-index:10}
    .line-items-total .label{color:#64748b}
    .line-items-total .amount{color:#0ea5e9;font-size:20px}
    /* Timing tracker display */
    .timing-display{display:inline-flex;align-items:center;gap:8px;background:rgba(255,255,255,0.9);padding:6px 12px;border-radius:8px;font-size:13px;margin-right:12px}
    .timing-display .timer-icon{font-size:16px}
    .timing-display .timer-value{font-weight:600;font-family:monospace;font-size:14px}
    .timing-display .timer-label{color:#64748b;font-size:11px}
  </style>
</head>
<body>
  <header class="top">
    <div><a href="/" style="color:#fff;text-decoration:none;font-weight:600">Bill Review @ JRK</a></div>
    <div style="display:flex;align-items:center">
      <div class="timing-display" id="timingDisplay">
        <span class="timer-icon">&#9201;</span>
        <div>
          <div class="timer-value" id="timerValue">0:00</div>
          <div class="timer-label">Time on invoice</div>
        </div>
      </div>
      <button class="btn secondary" id="improveBtn">IMPROVE</button>
      <button class="btn secondary" onclick="history.back()">Back</button>
    </div>
  </header>

  <div id="improveToast" class="improve-toast"></div>

  <div id="improveModal" class="improve-modal-overlay">
    <div class="improve-modal-box">
      <h2>Report Bug or Enhancement</h2>
      <label for="reportTitle">Title</label>
      <input type="text" id="reportTitle" placeholder="Brief summary of issue or enhancement" />
      <label for="reportDesc">Description</label>
      <textarea id="reportDesc" placeholder="Detailed description of what you'd like improved"></textarea>
      <div class="improve-modal-actions">
        <button class="btn secondary" id="cancelReport">Cancel</button>
        <button class="btn" id="submitReport">Submit</button>
      </div>
    </div>
  </div>
  <div class="wrap">
    <div class="row">
      <div class="card">
        <h1>PDF · Account {{ account }}</h1>
        <iframe id="pdfFrame" src=""></iframe>
        <div id="pdfHelper" class="muted" style="margin-top:8px;font-size:12px"></div>
      </div>
      <div class="resizer" id="resizer" title="Drag to resize"></div>
      <div class="card">
        <h1>Invoice Review</h1>
        <div class="toolbar">
          <button class="btn secondary" type="button" onclick="sendRework()">Send Back to Parser</button>
          <button class="btn" type="button" id="saveHeaderBtn" onclick="manualSaveHeader()">Save Header</button>
          <span id="headerSaveStatus" style="font-size:12px;color:#666"></span>
          <form method="post" action="/api/submit" onsubmit="return submitAll(event)" id="submitForm">
            <input type="hidden" name="date" value="{{ date }}" />
            <input type="hidden" id="idsField" name="ids" value="" />
            <button class="btn" id="submitBtn" type="submit">Submit</button>
          </form>
        </div>
        <details class="header" id="headerBox" open>
          <summary class="section-title">Invoice Header <span class="muted">(set once; use Save button to persist)</span></summary>
          <div class="field"><div class="lbl">EnrichedPropertyName</div>
            <div id="hdr_enrichedpropertyname_view">{{ header['EnrichedPropertyName'] }}</div>
            <select id="propName" name="EnrichedPropertyName" data-search="1"></select>
          </div>
          <div class="field"><div class="lbl">EnrichedPropertyID</div>
            <div id="hdr_enrichedpropertyid_view">{{ header['EnrichedPropertyID'] }}</div>
            <input id="propId" type="text" name="EnrichedPropertyID" value="{{ header['EnrichedPropertyID'] }}" />
          </div>
          <div class="field"><div class="lbl">EnrichedVendorName</div>
            <div id="hdr_vendor_view">{{ header['EnrichedVendorName'] }}</div>
            <select id="vendName" name="EnrichedVendorName" data-search="1"></select>
          </div>
          <div class="field"><div class="lbl">EnrichedVendorID</div>
            <div id="hdr_vendorid_view">{{ header['EnrichedVendorID'] }}</div>
            <input id="vendId" type="text" name="EnrichedVendorID" value="{{ header['EnrichedVendorID'] }}" />
          </div>
          <!-- Hidden field to store vendor location ID when user selects vendor+location from dropdown -->
          <input type="hidden" id="vendLocId" name="EnrichedVendorLocationID" value="{{ header.get('EnrichedVendorLocationID', '') }}" />
          <div class="field"><div class="lbl">Bill From</div>
            <div id="hdr_bill_from_view">{{ header['Bill From'] }}</div>
            <input id="billFrom" type="text" name="Bill From" value="{{ header['Bill From'] }}" />
          </div>
          <div class="field"><div class="lbl">Account Number</div>
            <div id="hdr_account_view">{{ header['Account Number'] }}</div>
            <input type="text" name="Account Number" value="{{ header['Account Number'] }}" />
          </div>
          <div class="field"><div class="lbl">Bill Period Start</div>
            <div id="hdr_bps_view">{{ header['Bill Period Start'] }}</div>
            <input type="text" name="Bill Period Start" value="{{ header['Bill Period Start'] }}" />
          </div>
          <div class="field"><div class="lbl">Bill Period End</div>
            <div id="hdr_bpe_view">{{ header['Bill Period End'] }}</div>
            <input type="text" name="Bill Period End" value="{{ header['Bill Period End'] }}" />
          </div>
          <div class="field"><div class="lbl">Bill Date</div>
            <div id="hdr_bd_view">{{ header['Bill Date'] }}</div>
            <input type="text" name="Bill Date" value="{{ header['Bill Date'] }}" />
          </div>
          <div class="field"><div class="lbl">Due Date</div>
            <div id="hdr_dd_view">{{ header['Due Date'] }}</div>
            <input type="text" name="Due Date" value="{{ header['Due Date'] }}" />
          </div>
          <div class="field"><div class="lbl">Service Address</div>
            <div id="hdr_addr_view">{{ header['Service Address'] }}</div>
            <input type="text" name="Service Address" value="{{ header['Service Address'] }}" />
          </div>
          <div class="field"><div class="lbl">Service City</div>
            <div id="hdr_city_view">{{ header['Service City'] }}</div>
            <input type="text" name="Service City" value="{{ header['Service City'] }}" />
          </div>
          <div class="field"><div class="lbl">Service State</div>
            <div id="hdr_state_view">{{ header['Service State'] }}</div>
            <input type="text" name="Service State" value="{{ header['Service State'] }}" />
          </div>
          <div class="field"><div class="lbl">Service Zipcode</div>
            <div id="hdr_zip_view">{{ header['Service Zipcode'] }}</div>
            <input type="text" name="Service Zipcode" value="{{ header['Service Zipcode'] }}" />
          </div>
          <div class="field"><div class="lbl">Special Instructions</div>
            <div id="hdr_si_view">{{ header['Special Instructions'] }}</div>
            <input type="text" name="Special Instructions" value="{{ header['Special Instructions'] }}" />
          </div>
        </details>
        <details open>
          <summary class="section-title">Invoice Line Items <span class="muted">— Original vs Override (autosaves)</span></summary>
          <div class="bar" style="justify-content:flex-start;gap:8px;margin:6px 0 8px">
            <button class="btn small" type="button" onclick="addLine()">Add Line</button>
            <button class="btn small" type="button" onclick="duplicateSelectedLines()">Duplicate Selected</button>
            <button class="btn small" type="button" onclick="flipAllHouse()">Flip All H/V</button>
            <button class="btn small secondary" type="button" onclick="resetSelected()">Reset Selected to Original</button>
            <button class="btn small danger" type="button" onclick="deleteSelectedLines()">Delete Selected</button>
          </div>
          <div class="line-items-total">
            <div class="label">Total Line Items:</div>
            <div class="amount" id="lineItemsTotal">$0.00</div>
          </div>
          <div class="lines" id="lines">
          {% for ln in lines %}
          <div class="line" data-pdf-id="{{ ln.pdf_id }}" data-line-id="{{ ln.line_id }}" data-orig-id="{{ ln.orig_id }}" data-pdf="{{ ln.pdf_link }}">
            <div style="display:flex;align-items:center;gap:10px;justify-content:space-between">
              <div class="line-num">Line #{{ ln.line_number }}</div>
              <div style="display:flex;align-items:center;gap:8px">
                <button type="button" class="minimize-btn" onclick="toggleMinimize(this)">Minimize</button>
                <label class="muted" style="display:flex;align-items:center;gap:6px"><input type="checkbox" class="line-pick" /> Select</label>
              </div>
            </div>
            <div class="line-summary">
              GL: {{ ln.original['EnrichedGLAccountNumber'] }} | {{ ln.original['Line Item Description'] }} | ${{ ln.original['Line Item Charge'] }}
            </div>
            <div class="field"><div class="lbl">EnrichedGLAccountNumber</div>
              <div>{{ ln.original['EnrichedGLAccountNumber'] }}</div>
              <select name="EnrichedGLAccountNumber" data-orig="{{ ln.original['EnrichedGLAccountNumber'] }}" data-search="1"></select>
            </div>
            <div class="field"><div class="lbl">EnrichedGLAccountName</div>
              <div>{{ ln.original['EnrichedGLAccountName'] }}</div>
              <select name="EnrichedGLAccountName" data-orig="{{ ln.original['EnrichedGLAccountName'] }}" data-search="1"></select>
            </div>
            <!-- Hidden field for GL Account ID - updated when GL Number/Name changes -->
            <input type="hidden" name="EnrichedGLAccountID" value="{{ ln.original['EnrichedGLAccountID'] }}" data-orig="{{ ln.original['EnrichedGLAccountID'] }}" />
            <div class="field"><div class="lbl">Meter Number</div>
              <div>{{ ln.original['Meter Number'] }}</div>
              <input type="text" name="Meter Number" value="{{ ln.original['Meter Number'] }}" data-orig="{{ ln.original['Meter Number'] }}" />
            </div>
            <div class="field"><div class="lbl">Meter Size</div>
              <div>{{ ln.original['Meter Size'] }}</div>
              <input type="text" name="Meter Size" value="{{ ln.original['Meter Size'] }}" data-orig="{{ ln.original['Meter Size'] }}" />
            </div>
            <div class="field"><div class="lbl">House Or Vacant</div>
              <div>{{ ln.original['House Or Vacant'] }}</div>
              <select name="House Or Vacant" data-orig="{{ ln.original['House Or Vacant'] }}"></select>
            </div>
            <div class="field"><div class="lbl">Utility Type</div>
              <div>{{ ln.original['Utility Type'] }}</div>
              <select name="Utility Type" data-orig="{{ ln.original['Utility Type'] }}" data-search="1"></select>
            </div>
            <div class="field"><div class="lbl">Line Item Description</div>
              <div>{{ ln.original['Line Item Description'] }}</div>
              <input type="text" name="Line Item Description" value="{{ ln.original['Line Item Description'] }}" data-orig="{{ ln.original['Line Item Description'] }}" />
            </div>
            <div class="field"><div class="lbl">Line Item Charge</div>
              <div>{{ ln.original['Line Item Charge'] }}</div>
              <input type="text" name="Line Item Charge" value="{{ ln.original['Line Item Charge'] }}" data-orig="{{ ln.original['Line Item Charge'] }}" />
            </div>
            <div class="field"><div class="lbl">Consumption Amount</div>
              <div>{{ ln.original['Consumption Amount'] }}</div>
              <input type="text" name="Consumption Amount" value="{{ ln.original['Consumption Amount'] }}" data-orig="{{ ln.original['Consumption Amount'] }}" />
            </div>
            <div class="field"><div class="lbl">ENRICHED CONSUMPTION</div>
              <div>{{ ln.original['ENRICHED CONSUMPTION'] }}</div>
              <input type="text" name="ENRICHED CONSUMPTION" value="{{ ln.original['ENRICHED CONSUMPTION'] }}" data-orig="{{ ln.original['ENRICHED CONSUMPTION'] }}" />
            </div>
            <div class="field"><div class="lbl">Unit of Measure</div>
              <div>{{ ln.original['Unit of Measure'] }}</div>
              <input type="text" name="Unit of Measure" value="{{ ln.original['Unit of Measure'] }}" data-orig="{{ ln.original['Unit of Measure'] }}" />
            </div>
            <div class="field"><div class="lbl">ENRICHED UOM</div>
              <div>{{ ln.original['ENRICHED UOM'] }}</div>
              <input type="text" name="ENRICHED UOM" value="{{ ln.original['ENRICHED UOM'] }}" data-orig="{{ ln.original['ENRICHED UOM'] }}" />
            </div>
            <div class="field"><div class="lbl">Previous Reading</div>
              <div>{{ ln.original['Previous Reading'] }}</div>
              <input type="text" name="Previous Reading" value="{{ ln.original['Previous Reading'] }}" data-orig="{{ ln.original['Previous Reading'] }}" />
            </div>
            <div class="field"><div class="lbl">Previous Reading Date</div>
              <div>{{ ln.original['Previous Reading Date'] }}</div>
              <input type="text" name="Previous Reading Date" value="{{ ln.original['Previous Reading Date'] }}" data-orig="{{ ln.original['Previous Reading Date'] }}" />
            </div>
            <div class="field"><div class="lbl">Current Reading</div>
              <div>{{ ln.original['Current Reading'] }}</div>
              <input type="text" name="Current Reading" value="{{ ln.original['Current Reading'] }}" data-orig="{{ ln.original['Current Reading'] }}" />
            </div>
            <div class="field"><div class="lbl">Current Reading Date</div>
              <div>{{ ln.original['Current Reading Date'] }}</div>
              <input type="text" name="Current Reading Date" value="{{ ln.original['Current Reading Date'] }}" data-orig="{{ ln.original['Current Reading Date'] }}" />
            </div>
            <div class="field"><div class="lbl">Rate</div>
              <div>{{ ln.original['Rate'] }}</div>
              <input type="text" name="Rate" value="{{ ln.original['Rate'] }}" data-orig="{{ ln.original['Rate'] }}" />
            </div>
          </div>
          {% endfor %}
          </div>
        
      </div>
    </div>
  </div>

  <div class="toast" id="submitToast">
    <div class="title">Submission</div>
    <div id="toastBody" class="muted"></div>
  </div>

  <script>
    // Load Choices.js
  </script>
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>
  <script>
    const dateVal = {{ date|tojson|safe }};
    const invoiceVal = {{ invoice|tojson|safe }};
    const pdfFrame = document.getElementById('pdfFrame');
    const _choicesMap = new WeakMap(); // select -> Choices instance
    // Global helper so other functions (e.g., resetSelected) can set values on Choices-backed selects
    function setSelectValue(sel, value){
      if (!sel) return;
      const v = value == null ? '' : String(value);
      const inst = _choicesMap.get(sel);
      if (inst) {
        try { inst.setChoiceByValue(v); } catch(e) { /* fall through */ }
        // Verify result; Choices can silently no-op if option not yet matched
        if (sel.value !== v) {
          sel.value = v;
          try { sel.dispatchEvent(new Event('change', { bubbles: true })); } catch(_){}
        }
      } else {
        sel.value = v;
      }
    }

    // Load first line's PDF once
    (function initPDF(){
      const first = document.querySelector('.line');
      const helper = document.getElementById('pdfHelper');
      if (!first){ if(helper){ helper.textContent = 'No lines found to determine PDF link.'; } return; }
      const pdf = first.getAttribute('data-pdf') || '';
      const pdfId = first.getAttribute('data-pdf-id') || '';
      // Build iframe URL and a clickable fallback link for the user
      let iframeUrl = '';
      try {
        const u = new URL(pdf);
        if (u.hostname.endsWith('.s3.amazonaws.com')){
          const key = (u.pathname || '').replace(/^\//,'');
          if (key){
            iframeUrl = '/pdf?k=' + encodeURIComponent(key) + '&date=' + encodeURIComponent(dateVal) + '&pdf_id=' + encodeURIComponent(pdfId) + '&cb=' + Date.now();
          }
        }
      } catch(e) { /* not a full URL; continue */ }
      if (!iframeUrl){
        const isUrl = /^(https?:)?\/\//i.test(pdf) || pdf.startsWith('s3://');
        const looksLikeKey = /^(Bill_Parser_|yyyy=mm=dd=|jrk-analytics-billing\/)/i.test(pdf) || (!isUrl && /\//.test(pdf));
        const q = looksLikeKey && !isUrl ? ('k=' + encodeURIComponent(pdf)) : (pdf ? ('u=' + encodeURIComponent(pdf)) : '');
        const base = '/pdf?' + (q ? (q + '&') : '') + 'date=' + encodeURIComponent(dateVal) + '&pdf_id=' + encodeURIComponent(pdfId) + '&cb=' + Date.now();
        iframeUrl = base;
      }
      pdfFrame.src = iframeUrl;
      if (helper){
        const open = document.createElement('a');
        open.href = iframeUrl;
        open.target = '_blank';
        open.rel = 'noopener';
        open.textContent = 'Open PDF in a new tab';
        helper.innerHTML = '';
        helper.appendChild(open);
      }
    })();

    // Apply draft data to a single line box (used by both single and batch loading)
    function applyDraftToLine(lineBox, draftFields) {
      if (!lineBox || !draftFields) return;
      for (const [k,v] of Object.entries(draftFields)) {
        const inp = lineBox.querySelector(`input[name="${k}"]`);
        if (inp) inp.value = v ?? '';
        const sel = lineBox.querySelector(`select[name="${k}"]`);
        if (sel) setSelectValue(sel, v ?? '');
      }
      // Restore deletion state if persisted
      const del = draftFields["__deleted__"];
      if (del && String(del).toLowerCase() !== '0' && String(del).toLowerCase() !== 'false'){
        lineBox.setAttribute('data-deleted','1');
        lineBox.style.opacity = '0.5';
        lineBox.querySelectorAll('input,select,button,textarea').forEach(el => { try{ el.disabled = true; }catch(_){ } });
      }
    }

    // BATCH load all drafts in a single request (PERF optimization - replaces N individual calls)
    async function loadAllDraftsBatch() {
      const lines = document.querySelectorAll('.line');
      if (lines.length === 0) return;

      // Collect all pdf_id/line_id pairs including __header__
      const items = [];
      const first = lines[0];
      const firstPdfId = first?.getAttribute('data-pdf-id');

      // Include header draft
      if (firstPdfId) {
        items.push({ pdf_id: firstPdfId, line_id: '__header__' });
      }

      // Include all line drafts
      lines.forEach(lineBox => {
        const pdf_id = lineBox.getAttribute('data-pdf-id');
        const line_id = lineBox.getAttribute('data-line-id');
        if (pdf_id && line_id) {
          items.push({ pdf_id, line_id });
        }
      });

      if (items.length === 0) return;

      try {
        const r = await fetch('/api/drafts/batch', {
          method: 'POST',
          credentials: 'same-origin',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ items })
        });
        const j = await r.json();
        if (!j || !j.drafts) return;

        // Apply header draft
        if (firstPdfId) {
          const headerKey = `${firstPdfId}#__header__`;
          const headerDraft = j.drafts[headerKey];
          if (headerDraft && headerDraft.fields) {
            applyHeaderDraft(headerDraft.fields);
          }
        }

        // Apply line drafts
        lines.forEach(lineBox => {
          const pdf_id = lineBox.getAttribute('data-pdf-id');
          const line_id = lineBox.getAttribute('data-line-id');
          const key = `${pdf_id}#${line_id}`;
          const draft = j.drafts[key];
          if (draft && draft.fields) {
            applyDraftToLine(lineBox, draft.fields);
          }
        });

        console.log(`[review] Batch loaded ${Object.keys(j.drafts).length} drafts in 1 request`);
      } catch (e) {
        console.error('[review] Batch draft load failed, falling back to individual loads', e);
        // Fallback to individual loads if batch fails
        lines.forEach(loadDraft);
      }
    }

    // Load and create new lines that were added in previous sessions but not yet submitted
    async function loadNewLinesFromDrafts() {
      const first = document.querySelector('.line');
      if (!first) return;
      const pdfId = first.getAttribute('data-pdf-id');
      if (!pdfId) return;

      try {
        const r = await fetch(`/api/drafts/new-lines?pdf_id=${encodeURIComponent(pdfId)}`, { credentials: 'same-origin' });
        const j = await r.json();
        if (!j || !j.new_lines || j.new_lines.length === 0) return;

        console.log(`[review] Found ${j.new_lines.length} new lines from drafts`);

        const container = document.getElementById('lines');
        if (!container) return;

        // Create DOM elements for each new line
        j.new_lines.forEach(newLine => {
          // Check if this line already exists (avoid duplicates)
          if (document.querySelector(`.line[data-line-id="${newLine.line_id}"]`)) return;

          // Clone the first line as template
          const clone = first.cloneNode(true);
          clone.setAttribute('data-new', '1');
          clone.removeAttribute('data-orig-id');
          clone.setAttribute('data-line-id', newLine.line_id);

          // Clear all inputs first
          clone.querySelectorAll('input[type=text]').forEach(i => { i.value = ''; });
          clone.querySelectorAll('select').forEach(s => { try { s.value = ''; } catch(_) {} });

          // Reset checkbox
          const pick = clone.querySelector('.line-pick');
          if (pick) pick.checked = false;

          // Apply saved field values
          if (newLine.fields) {
            for (const [k, v] of Object.entries(newLine.fields)) {
              if (k === '__deleted__') continue;
              const inp = clone.querySelector(`input[name="${k}"]`);
              if (inp) inp.value = v ?? '';
              const sel = clone.querySelector(`select[name="${k}"]`);
              if (sel) {
                try { sel.value = v ?? ''; } catch(_) {}
              }
            }
          }

          // Append to container
          container.appendChild(clone);

          // Initialize event handlers
          if (window.initLineSelects) window.initLineSelects(clone);
          bindLineAutosave(clone);
        });

        // Renumber and update total
        renumberLines();
        updateLineItemsTotal();
      } catch (e) {
        console.error('[review] Failed to load new lines from drafts:', e);
      }
    }

    // Helper to apply header draft fields
    function applyHeaderDraft(fields) {
      if (!fields) return;
      const headerBox = document.querySelector('.header-card');
      if (!headerBox) return;
      for (const [k,v] of Object.entries(fields)) {
        const inp = headerBox.querySelector(`input[name="${k}"]`);
        const viewId = (k === 'EnrichedVendorName') ? 'hdr_vendor_view'
                      : (k === 'EnrichedVendorID') ? 'hdr_vendorid_view'
                      : `hdr_${k.replaceAll(' ','_').toLowerCase()}_view`;
        const view = document.getElementById(viewId);
        if (inp && v != null && String(v).trim() !== '') inp.value = v;
        const sel = headerBox.querySelector(`select[name="${k}"]`);
        if (sel && v != null && String(v).trim() !== '') setSelectValue(sel, v);
        if (view && v != null && String(v).trim() !== '') view.textContent = v;
      }
    }

    // Single draft load (for newly added lines or fallback)
    async function loadDraft(lineBox) {
      const pdf_id = lineBox.getAttribute('data-pdf-id');
      const line_id = lineBox.getAttribute('data-line-id');
      const r = await fetch(`/api/drafts?pdf_id=${encodeURIComponent(pdf_id)}&line_id=${encodeURIComponent(line_id)}`, { credentials: 'same-origin' });
      const j = await r.json();
      if (j && j.draft && j.draft.fields) {
        applyDraftToLine(lineBox, j.draft.fields);
      }
    }

    async function sendRework(){
      try{
        const first = document.querySelector('.line');
        if (!first){ alert('No lines found.'); return; }
        const pdfId = first.getAttribute('data-pdf-id');
        // Derive explicit S3 key for backend to avoid brittle URL parsing
        let pdfKey = '';
        try{
          const raw = first.getAttribute('data-pdf') || '';
          if (raw){
            if (/^s3:\/\//i.test(raw)){
              // s3://bucket/key
              const m = raw.match(/^s3:\/\/[^/]+\/(.+)$/i);
              if (m) pdfKey = m[1];
            } else if (/^https?:\/\//i.test(raw)){
              // Try S3 virtual-hosted style bucket.s3.amazonaws.com/key
              try{
                const u = new URL(raw);
                if (u.hostname.includes('.s3.')){
                  pdfKey = (u.pathname||'').replace(/^\//,'');
                }
              }catch(_){ }
            } else if (raw.includes('/')){
              // looks like a bucket-relative key already
              pdfKey = raw.replace(/^\//,'');
            }
          }
          // Fallback: parse currently loaded iframe src
          if (!pdfKey) {
            try{
              const fr = document.getElementById('pdfFrame');
              if (fr && fr.src){
                const u = new URL(fr.src, window.location.origin);
                const k = u.searchParams.get('k');
                const uparam = u.searchParams.get('u');
                if (k){
                  pdfKey = k.replace(/^\//,'');
                } else if (uparam){
                  // if u is an s3 url, extract path as key
                  try{
                    const uu = new URL(uparam);
                    if (uu.hostname.includes('.s3.')){
                      pdfKey = (uu.pathname||'').replace(/^\//,'');
                    }
                  }catch(_){ }
                }
              }
            }catch(_){ }
          }
        }catch(_){ }
        const notes = window.prompt('Tell the parser what went wrong (optional):', '');
        if (notes === null) return; // cancelled
        const fd = new FormData();
        fd.append('date', dateVal);
        fd.append('pdf_id', pdfId || '');
        fd.append('notes', notes || '');
        if (pdfKey) fd.append('pdf_key', pdfKey);
        // Optional: explicit expected line count to avoid regex misses downstream
        const exp = window.prompt('Optional: expected total line count (number only). Leave blank to skip.', '');
        if (exp != null){
          const n = String(exp).trim();
          if (/^\d+$/.test(n)) fd.append('expected_lines', n);
        }
        // Pass current Bill From through to REWORK so parser/enricher can use it
        const bfInput = document.querySelector('input[name="Bill From"]');
        const bfView = document.getElementById('hdr_bill_from_view');
        const billFrom = (bfInput && bfInput.value) ? bfInput.value : ((bfView && bfView.textContent) ? bfView.textContent.trim() : '');
        if (billFrom) fd.append('bill_from', billFrom);
        // Also pass Account Number and Bill Date for fallback row lookup
        const acctInput = document.querySelector('input[name="Account Number"]');
        const acctView = document.getElementById('hdr_account_view');
        const acctNum = (acctInput && acctInput.value) ? acctInput.value : ((acctView && acctView.textContent) ? acctView.textContent.trim() : '');
        if (acctNum) fd.append('account_number', acctNum);
        const bdInput = document.querySelector('input[name="Bill Date"]');
        const bdView = document.getElementById('hdr_bd_view');
        const billDate = (bdInput && bdInput.value) ? bdInput.value : ((bdView && bdView.textContent) ? bdView.textContent.trim() : '');
        if (billDate) fd.append('bill_date', billDate);
        const r = await fetch('/api/rework', { method: 'POST', body: fd });
        const j = await r.json();
        if (!r.ok || !j || j.error){
          alert('Failed to send to REWORK: ' + (j && (j.error||JSON.stringify(j))));
          return;
        }
        // toast and redirect back to invoices list
        const toast = document.getElementById('submitToast');
        const body = document.getElementById('toastBody');
        body.innerHTML = `<div class="ok"><strong>Sent back to parser.</strong></div><div class="muted">Removed current artifacts: ${j.deleted||0}. Tracking: <code>${j.copied_key||''}</code></div>`;
        toast.classList.add('show');
        try{ const linesBox = document.getElementById('lines'); if (linesBox) linesBox.innerHTML = ''; }catch(_){ }
        const cb = Date.now();
        setTimeout(()=>{ window.location.replace(`/invoices?date=${encodeURIComponent(dateVal)}&cb=${cb}`); }, 800);
      }catch(e){ alert('Error: ' + e); }
    }

    function collectFields(lineBox){
      const fields = {};
      lineBox.querySelectorAll('input').forEach(i => fields[i.name] = i.value);
      lineBox.querySelectorAll('select').forEach(s => fields[s.name] = s.value);
      return fields;
    }

    function flipHouse(btn){
      try{
        const line = btn.closest('.line');
        if (!line) return;
        const hv = line.querySelector('select[name="House Or Vacant"]');
        if (!hv) return;
        const cur = String(hv.value || hv.getAttribute('data-orig') || '').trim().toUpperCase();
        const next = (cur === 'HOUSE') ? 'VACANT' : 'HOUSE';
        setSelectValue(hv, next);
        saveDraft(line);
      }catch(_){ }
    }

    function _hvOptionMap(sel){
      const map = { house: null, vacant: null };
      try{
        const opts = sel ? Array.from(sel.options || []) : [];
        for (const o of opts){
          const v = String(o.value || o.text || '').trim();
          const n = v.toUpperCase();
          if (!map.house && (n === 'HOUSE')) map.house = v;
          if (!map.vacant && (n === 'VACANT')) map.vacant = v;
        }
      }catch(_){ }
      // fallbacks
      if (!map.house) map.house = 'HOUSE';
      if (!map.vacant) map.vacant = 'VACANT';
      return map;
    }

    function _utilToGlStem(utilVal){
      const u = String(utilVal||'').trim().toLowerCase();
      if (!u) return '';
      if (u === 'electricity') return 'Electric';
      if (u === 'electric') return 'Electric';
      if (u === 'gas') return 'Gas';
      if (u === 'water') return 'Water';
      if (u === 'sewer') return 'Sewer';
      if (u === 'trash') return 'Trash';
      // default: title-case the raw utility
      return u.replace(/\b\w/g, c=>c.toUpperCase());
    }

    // Build the GL account name based on utility type and House/Vacant
    // Only Electric uses "House Electric", others use just the utility name for House
    // e.g., House: "House Electric", "Gas", "Water", "Sewer"
    //       Vacant: "Vacant Electric", "Vacant Gas", "Vacant Water", "Vacant Sewer"
    function _buildGlName(stem, isHouse){
      if (!stem) return '';
      if (isHouse) {
        // Only Electric uses "House" prefix, others have no prefix
        if (stem === 'Electric') return 'House Electric';
        return stem; // Gas, Water, Sewer just use the utility name
      } else {
        // Vacant always uses "Vacant" prefix
        return 'Vacant ' + stem;
      }
    }

    function applyHVGL(line, hvUpper){
      try{
        const utilSel = line.querySelector('select[name="Utility Type"]');
        const glNameSel = line.querySelector('select[name="EnrichedGLAccountName"]');
        const glNumSel = line.querySelector('select[name="EnrichedGLAccountNumber"]');
        if (!utilSel || (!glNameSel && !glNumSel)) return;
        const stem = _utilToGlStem(utilSel.value || utilSel.getAttribute('data-orig') || '');
        if (!stem) return;
        const isHouse = (hvUpper === 'HOUSE');
        const desiredName = _buildGlName(stem, isHouse);
        // First set GL Name if present
        if (glNameSel){ setSelectValue(glNameSel, desiredName); }
        // Then set GL Number using map, if available
        try{
          const map = (window._glNameToNum||{});
          const num = map[desiredName] || '';
          if (num && glNumSel){ setSelectValue(glNumSel, num); }
        }catch(_){ }
        // If only number exists but name select missing, try backfilling name from number
        if (!glNameSel && glNumSel){
          try{
            const rev = (window._glNumToName||{});
            const nm = rev[glNumSel.value] || '';
            if (nm && nm !== desiredName){ /* nothing to set without name select */ }
          }catch(_){ }
        }
      }catch(_){ }
    }

    function flipAllHouse(){
      try{
        let needsRetry = false;
        document.querySelectorAll('.line').forEach(line => {
          try{
            const hv = line.querySelector('select[name="House Or Vacant"]');
            if (!hv) return;
            // if options not loaded yet, mark for retry
            if (!hv.options || hv.options.length === 0){ needsRetry = true; return; }
            const map = _hvOptionMap(hv);
            const curRaw = String(hv.value || hv.getAttribute('data-orig') || '').trim();
            const cur = curRaw.toUpperCase();
            const isCurHouse = (cur === 'HOUSE' || cur === '');
            const nextVal = isCurHouse ? map.vacant : map.house;

            // Set HoV directly
            hv.value = nextVal;

            // Get GL selects
            const glNameSel = line.querySelector('select[name="EnrichedGLAccountName"]');
            const glNumSel = line.querySelector('select[name="EnrichedGLAccountNumber"]');
            const utilSel = line.querySelector('select[name="Utility Type"]');

            // Calculate desired GL Name
            // isCurHouse means current state is House, so we're flipping TO Vacant (isHouse=false)
            // !isCurHouse means current state is Vacant, so we're flipping TO House (isHouse=true)
            const isFlippingToHouse = !isCurHouse;
            const stem = _utilToGlStem(utilSel?.value || utilSel?.getAttribute('data-orig') || '');
            const desiredName = stem ? _buildGlName(stem, isFlippingToHouse) : '';

            if (desiredName && glNameSel) {
              // Try to find exact match first
              let found = false;
              for (const opt of glNameSel.options) {
                if (opt.value === desiredName || opt.text === desiredName) {
                  glNameSel.value = desiredName;
                  found = true;
                  break;
                }
              }
              // If no exact match, try case-insensitive
              if (!found) {
                const desiredLower = desiredName.toLowerCase();
                for (const opt of glNameSel.options) {
                  if ((opt.value||'').toLowerCase() === desiredLower || (opt.text||'').toLowerCase() === desiredLower) {
                    glNameSel.value = opt.value;
                    found = true;
                    break;
                  }
                }
              }
              // If still not found, add it as an option and select it
              if (!found) {
                const newOpt = document.createElement('option');
                newOpt.value = desiredName;
                newOpt.text = desiredName;
                glNameSel.insertBefore(newOpt, glNameSel.firstChild);
                glNameSel.value = desiredName;
              }

              // Update Choices.js display if wrapped
              const inst = window._choicesMap?.get(glNameSel);
              if (inst) {
                try { inst.setChoiceByValue(glNameSel.value); } catch(_) {}
              }

              // Set GL Number from mapping
              if (glNumSel) {
                const num = (window._glNameToNum||{})[glNameSel.value] || '';
                if (num) {
                  glNumSel.value = num;
                  const numInst = window._choicesMap?.get(glNumSel);
                  if (numInst) {
                    try { numInst.setChoiceByValue(num); } catch(_) {}
                  }
                }
              }
            }

            saveDraft(line);
          }catch(e){ console.error('flipAllHouse error:', e); }
        });
        if (needsRetry){ setTimeout(flipAllHouse, 250); }
      }catch(_){ }
    }

    // simple debounce
    function debounce(fn, ms){ let t; return function(){ const ctx=this, args=arguments; clearTimeout(t); t=setTimeout(()=>fn.apply(ctx,args), ms); }; }

    const debouncedSaves = new WeakMap();
    const lastLineSig = new WeakMap();

    async function saveDraft(lineBox){
      const payload = {
        pdf_id: lineBox.getAttribute('data-pdf-id'),
        line_id: lineBox.getAttribute('data-line-id'),
        date: dateVal,
        invoice: invoiceVal,
        fields: (()=>{ const f = collectFields(lineBox); if (lineBox.hasAttribute('data-deleted')) f['__deleted__'] = '1'; return f; })()
      };
      try{
        const sig = JSON.stringify(payload.fields);
        if (lastLineSig.get(lineBox) === sig) return; // no changes
        const resp = await fetch('/api/drafts', { method:'PUT', credentials: 'same-origin', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
        if (resp.ok) lastLineSig.set(lineBox, sig);
      } catch(_){ /* swallow to avoid blocking UI */ }
    }

    // Immediately persist all current values for header and lines (no debounce)
    async function saveAllDrafts(){
      const tasks = [];
      try{
        const first = document.querySelector('.line');
        if (first){
          // header draft
          const headerPayload = {
            pdf_id: first.getAttribute('data-pdf-id'),
            line_id: '__header__',
            date: dateVal,
            invoice: invoiceVal,
            fields: collectHeader()
          };
          tasks.push(fetch('/api/drafts', { method:'PUT', credentials: 'same-origin', headers:{'Content-Type':'application/json'}, body: JSON.stringify(headerPayload)}));
        }
      }catch(_){ }
      // line drafts
      document.querySelectorAll('.line').forEach(lineBox => {
        try{
          const payload = {
            pdf_id: lineBox.getAttribute('data-pdf-id'),
            line_id: lineBox.getAttribute('data-line-id'),
            date: dateVal,
            invoice: invoiceVal,
            fields: collectFields(lineBox)
          };
          tasks.push(fetch('/api/drafts', { method:'PUT', credentials: 'same-origin', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)}));
        }catch(_){ }
      });
      try{ await Promise.allSettled(tasks); } catch(_){ }
    }

    // autosave on change (inputs and selects)
    document.querySelectorAll('.line input').forEach(inp => {
      const line = inp.closest('.line');
      if (!debouncedSaves.has(line)) debouncedSaves.set(line, debounce(saveDraft, 250));
      const saver = debouncedSaves.get(line);
      inp.addEventListener('change', e => saver(e.target.closest('.line')));
      inp.addEventListener('input', e => saver(e.target.closest('.line')));
      // Update total when Line Item Charge changes
      if (inp.name === 'Line Item Charge'){
        inp.addEventListener('input', updateLineItemsTotal);
        inp.addEventListener('change', updateLineItemsTotal);
      }
    });
    document.querySelectorAll('.line select').forEach(sel => {
      const line = sel.closest('.line');
      if (!debouncedSaves.has(line)) debouncedSaves.set(line, debounce(saveDraft, 250));
      const saver = debouncedSaves.get(line);
      sel.addEventListener('change', e => saver(e.target.closest('.line')));
    });

    // initial load drafts (batch mode for performance - 1 request instead of N)
    // Then load any new lines that were added in previous sessions
    loadAllDraftsBatch().then(() => {
      loadNewLinesFromDrafts();
    });

    // Calculate initial total after page loads
    setTimeout(updateLineItemsTotal, 100);

    // --- Dropdown options for Enriched fields ---
    // Datalists are placed at the end of body
    function initOptions(){
      if (window._optionsInitStarted) { try{ console.log('[review] initOptions: already started'); }catch(_){ } return; }
      window._optionsInitStarted = true;
      try{ console.log('[review] initOptions: start'); }catch(_){ }
      // Load full master catalogs (properties, vendors, gl accounts, utilities)
      fetch(`/api/catalogs`, { credentials: 'same-origin' })
        .then(async r => {
          if (!r.ok){
            const txt = await r.text().catch(()=> '');
            console.error('[review] /api/catalogs error', r.status, txt);
            throw new Error('options http ' + r.status);
          }
          return r.json();
        })
        .then(data => {
          try{ console.log('[review] initOptions: catalogs loaded', { p:(data?.properties||[]).length, v:(data?.vendors||[]).length, g:(data?.gl_accounts||[]).length }); }catch(_){ }
          // helper: enhance a native select with Choices.js search if marked
          const enhanceSearch = (sel) => {
            if (!sel || sel.dataset.enhanced === '1') return null;
            const c = new Choices(sel, {
              searchEnabled: true,
              shouldSort: false,
              searchResultLimit: 1000,
              itemSelectText: '',
              placeholder: true,
              allowHTML: false,
            });
            sel.dataset.enhanced = '1';
            _choicesMap.set(sel, c);
            // After Choices enhances, ensure change events persist drafts
            if (!sel.dataset.bound){
              sel.addEventListener('change', (e) => {
                const line = sel.closest('.line');
                if (line) {
                  saveDraft(line);
                } else if (sel.closest('#headerBox')) {
                  saveHeader();
                }
              });
              sel.addEventListener('choice', () => {
                const line = sel.closest('.line');
                if (line) { saveDraft(line); } else if (sel.closest('#headerBox')) { saveHeader(); }
              });
              sel.dataset.bound='1';
            }
            return c;
          };
          // set value on native or Choices-backed select
          const setSelectValue = (sel, value) => {
            const v = value == null ? '' : String(value);
            const inst = _choicesMap.get(sel);
            if (inst) {
              try { inst.setChoiceByValue(v); } catch(e) { sel.value = v; }
            } else {
              sel.value = v;
            }
          };
          // Initialize selects inside a newly added/duplicated line
          window.initLineSelects = (line) => {
            if (!line) return;
            // Wait until catalogs are loaded
            if (!window._optHTML || !window._optHTML.glOpts){ setTimeout(() => window.initLineSelects(line), 150); return; }
            // Ensure entire line is interactive
            try{ line.removeAttribute('data-deleted'); line.style.opacity=''; }catch(_){ }
            line.querySelectorAll('input,select,button,textarea').forEach(el => { try{ el.disabled=false; el.style.pointerEvents='auto'; }catch(_){} });
            const rebuildFreshNative = (selectorName, html) => {
              try{
                // Prefer replacing the specific .choices wrapper that owns this select
                let oldSel = line.querySelector(`.choices select[name="${selectorName}"]`) || line.querySelector(`select[name="${selectorName}"]`);
                if (!oldSel) return null;
                const wrapper = oldSel.closest('.choices');
                const fresh = document.createElement('select');
                fresh.setAttribute('name', selectorName);
                fresh.style.display = '';
                fresh.style.pointerEvents = 'auto';
                fresh.className = '';
                fresh.innerHTML = html;
                try{ fresh.removeAttribute('hidden'); }catch(_){ }
                try{ fresh.removeAttribute('data-search'); }catch(_){ }
                try{ fresh.disabled = false; }catch(_){ }
                try{ fresh.readOnly = false; }catch(_){ }
                try{ fresh.tabIndex = 0; }catch(_){ }
                if (wrapper && wrapper.parentElement){ wrapper.parentElement.replaceChild(fresh, wrapper); }
                else { oldSel.replaceWith(fresh); }
                // Keep as native select for reliability on new/duplicated lines
                // After the DOM settles, remove any stray .choices wrappers that may get added
                try{ setTimeout(() => { const w = fresh.closest('.line'); w && w.querySelectorAll('.choices').forEach(x => { try{ x.remove(); }catch(_){} }); }, 0); }catch(_){ }
                return fresh;
              }catch(_){ return null; }
            };
            try{
              const htmls = (window._optHTML || {});
              const numSel = rebuildFreshNative('EnrichedGLAccountNumber', htmls.glOpts || '<option value=""></option>');
              const nameSel = rebuildFreshNative('EnrichedGLAccountName', htmls.glNameOpts || '<option value=""></option>');
              const utilSel = rebuildFreshNative('Utility Type', (htmls.utilOpts || '<option value=""></option>'));
              // Bind autosave on change for the new selects
              const saver = (ln => (e) => saveDraft(ln))(line);
              const syncFromNum = (e) => {
                try{
                  const num = (numSel && numSel.value) || '';
                  const mapped = (window._glNumToName||{})[num] || '';
                  if (nameSel && mapped && nameSel.value !== mapped){ setSelectValue(nameSel, mapped); }
                  // Also update GL ID hidden field
                  const idField = line.querySelector('input[name="EnrichedGLAccountID"]');
                  const mappedId = (window._glNumToId||{})[num] || '';
                  if (idField && mappedId) idField.value = mappedId;
                }catch(_){ }
                saver(e);
              };
              const syncFromName = (e) => {
                try{
                  const nm = (nameSel && nameSel.value) || '';
                  const mapped = (window._glNameToNum||{})[nm] || '';
                  if (numSel && mapped && numSel.value !== mapped){ setSelectValue(numSel, mapped); }
                  // Also update GL ID hidden field
                  const idField = line.querySelector('input[name="EnrichedGLAccountID"]');
                  const mappedId = (window._glNumToId||{})[mapped] || '';
                  if (idField && mappedId) idField.value = mappedId;
                }catch(_){ }
                saver(e);
              };
              if (numSel) numSel.addEventListener('change', syncFromNum);
              if (nameSel) nameSel.addEventListener('change', syncFromName);
              if (utilSel) utilSel.addEventListener('change', saver);
            }catch(_){ }
          };
          // Helpers
          const esc = (s) => String(s).replace(/"/g,'&quot;').replace(/</g,'&lt;');
          const toTitle = (s) => String(s||'').toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
          const propMap = {}; // name -> id
          const propIdToName = {}; // id -> name
          const vendMap = {}; // name -> id
          const vendIdToName = {}; // id -> name
          const vendLocMap = {}; // name -> locationId (for capturing location when vendor selected)
          const glNumToName = {};   // number -> name
          const glNameToNum = {};   // name -> number
          const glNumToId = {};     // number -> id (for charge code mapping)
          (data.properties||[]).forEach(o => { propMap[o.name] = o.id || ''; if (o.id) propIdToName[String(o.id)] = o.name || ''; });
          (data.vendors||[]).forEach(o => {
            vendMap[o.name] = o.id || '';
            if (o.id) vendIdToName[String(o.id)] = o.name || '';
            if (o.locationId) vendLocMap[o.name] = o.locationId;
          });
          (data.gl_accounts||[]).forEach(o => {
            glNumToName[o.number] = o.name || '';
            if (o.name) glNameToNum[o.name] = o.number || '';
            if (o.id) glNumToId[o.number] = o.id;
          });

          // Build option HTML strings once
          const propOpts = ['<option value=""></option>'].concat((data.properties||[]).map(o => `<option value="${o.name.replace(/"/g,'&quot;')}">${o.name.replace(/</g,'&lt;')}</option>`)).join('');
          const vendOpts = ['<option value=""></option>'].concat((data.vendors||[]).map(o => `<option value="${o.name.replace(/"/g,'&quot;')}">${o.name.replace(/</g,'&lt;')}</option>`)).join('');
          const glOpts = ['<option value=""></option>'].concat((data.gl_accounts||[]).map(o => `<option value="${o.number.replace(/"/g,'&quot;')}">${o.number.replace(/</g,'&lt;')}</option>`)).join('');
          const glNameOpts = ['<option value=""></option>'].concat((data.gl_accounts||[]).map(o => `<option value="${(o.name||'').replace(/"/g,'&quot;')}">${(o.name||'').replace(/</g,'&lt;')}</option>`)).join('');
          // cache option HTML and GL maps for cloning/sync
          window._optHTML = { propOpts, vendOpts, glOpts, glNameOpts };
          window._glNumToName = glNumToName;
          window._glNameToNum = glNameToNum;
          window._glNumToId = glNumToId;
          window._vendLocMap = vendLocMap; // vendor displayName -> locationId
          const utilOpts = ['<option value=""></option>']
            .concat((data.utilities||[]).map(u => {
              const t = toTitle(String(u||''));
              return `<option value="${t.replace(/"/g,'&quot;')}">${t.replace(/</g,'&lt;')}</option>`
            }))
            .join('');
          window._optHTML.utilOpts = utilOpts;

          // Header selects
          const propNameSel = document.getElementById('propName');
          const propId = document.getElementById('propId');
          const vendNameSel = document.getElementById('vendName');
          const vendId = document.getElementById('vendId');
          if (propNameSel){
            // Determine desired name using (select value) OR (header view text) OR (ID -> name)
            const viewEl = document.getElementById('hdr_enrichedpropertyname_view');
            const idEl = document.getElementById('propId');
            const curId = (idEl && idEl.value ? String(idEl.value).trim() : '');
            let desiredName = (propNameSel.value||'').trim() || (viewEl?.textContent?.trim() || '');
            if (!desiredName && curId){ desiredName = propIdToName[curId] || ''; }
            // If we have neither a name nor an id, do not touch current DOM values
            if (desiredName || curId){
              // Build options and preserve desiredName if not present
              if (desiredName && !propOpts.includes(`value="${desiredName.replace(/"/g,'&quot;')}"`)){
                propNameSel.innerHTML = `<option value="${desiredName.replace(/"/g,'&quot;')}">${desiredName.replace(/</g,'&lt;')}</option>` + propOpts;
              } else {
                propNameSel.innerHTML = propOpts;
              }
              enhanceSearch(propNameSel);
              if (desiredName) setSelectValue(propNameSel, desiredName);
              // Ensure ID mirrors name when we actually have a name; otherwise keep existing ID
              const resolvedId = desiredName ? (propMap[desiredName] || curId || '') : curId;
              if (idEl && resolvedId) idEl.value = resolvedId;
              if (viewEl && desiredName) viewEl.textContent = desiredName;
              const idView = document.getElementById('hdr_enrichedpropertyid_view');
              if (idView && (idEl?.value||'').trim()) idView.textContent = idEl.value.trim();
            }
          }
          if (vendNameSel){
            // Use the actual view element id for vendor name
            const vendViewEl = document.getElementById('hdr_vendor_view');
            // Prefer current select value, then view text, then resolve from EnrichedVendorID
            const vendIdEl = document.getElementById('vendId');
            let curVend = (vendNameSel.value||'').trim() || vendViewEl?.textContent?.trim() || '';
            if (!curVend && vendIdEl && vendIdEl.value){
              const byId = vendIdToName[String(vendIdEl.value).trim()];
              if (byId) curVend = byId;
            }
            // Build options and ensure current vendor text exists even if not in catalogs
            const parser = new DOMParser();
            const doc = parser.parseFromString(`<select>${vendOpts}</select>`, 'text/html');
            const hasCur = Array.from(doc.querySelectorAll('option')).some(o => (o.value||'').trim().toLowerCase() === curVend.trim().toLowerCase());
            vendNameSel.innerHTML = (curVend && !hasCur ? `<option value="${curVend.replace(/"/g,'&quot;')}">${curVend.replace(/</g,'&lt;')}</option>` : '') + vendOpts;
            enhanceSearch(vendNameSel);
            setSelectValue(vendNameSel, curVend || '');
          }
          const debSaveHeader = debounce(saveHeader, 200);
          const syncProp = () => {
            if (!propId || !propNameSel) return;
            const name = (propNameSel.value || '').trim();
            if (!name) return; // don't overwrite existing ID when nothing is selected
            const newId = propMap[name] || '';
            const oldId = propId.value || '';
            if (newId !== oldId) { propId.value = newId; }
            const vEl = document.getElementById('hdr_enrichedpropertyname_view');
            if (vEl) vEl.textContent = name;
            debSaveHeader();
          };
          const syncVend = () => {
            if (vendId && vendNameSel){
              const selectedName = vendNameSel.value || '';
              const mapped = vendMap[selectedName] || '';
              // Only overwrite the ID when we have a mapped value; otherwise preserve whatever was loaded from the header
              if (mapped) { vendId.value = mapped; }
              // Also capture the vendor location ID so we don't have to prompt at POST time
              const vendLocIdEl = document.getElementById('vendLocId');
              const mappedLoc = (window._vendLocMap || {})[selectedName] || '';
              if (vendLocIdEl) { vendLocIdEl.value = mappedLoc; }
              const vEl = document.getElementById('hdr_vendor_view');
              if (vEl) vEl.textContent = selectedName;
              debSaveHeader();
            }
          };
          if (propNameSel){ propNameSel.addEventListener('change', syncProp); }
          if (vendNameSel){ vendNameSel.addEventListener('change', syncVend); syncVend(); }
          // header selects are searchable via Choices.js

          // Line selects initializer (reused for existing and newly added/duplicated lines)
          function initLineSelects(line){
            if (!line) return;
            // Ensure controls are selects (in case created as inputs for new lines)
            const ensureSelect = (line, name, dataOrig) => {
              let el = line.querySelector(`select[name="${name}"]`);
              if (!el){
                const input = line.querySelector(`input[name="${name}"]`);
                if (input){
                  const sel = document.createElement('select');
                  sel.name = name; if (dataOrig != null) sel.setAttribute('data-orig', dataOrig);
                  sel.setAttribute('data-search','1');
                  input.parentElement.replaceChild(sel, input);
                  el = sel;
                }
              }
              return el;
            };

            const glSel = ensureSelect(line, 'EnrichedGLAccountNumber', line.querySelector('input[name="EnrichedGLAccountNumber"]')?.getAttribute('data-orig')) || line.querySelector('select[name="EnrichedGLAccountNumber"]');
            const glNameSel = ensureSelect(line, 'EnrichedGLAccountName', line.querySelector('input[name="EnrichedGLAccountName"]')?.getAttribute('data-orig')) || line.querySelector('select[name="EnrichedGLAccountName"]');
            const utilSel = ensureSelect(line, 'Utility Type', line.querySelector('input[name="Utility Type"]')?.getAttribute('data-orig')) || line.querySelector('select[name="Utility Type"]');
            const hovSel = ensureSelect(line, 'House Or Vacant', line.querySelector('input[name="House Or Vacant"]')?.getAttribute('data-orig')) || line.querySelector('select[name="House Or Vacant"]');

            if (glSel){
              const cur = (glSel.value || glSel.getAttribute('data-orig') || '').trim();
              const esc2 = (s) => String(s).replace(/"/g,'&quot;').replace(/</g,'&lt;');
              if (cur && !(cur in glNumToName)){
                glSel.innerHTML = `<option value="${esc2(cur)}">${esc2(cur)}</option>` + glOpts;
              } else {
                glSel.innerHTML = glOpts;
              }
              enhanceSearch(glSel);
              setSelectValue(glSel, cur || glSel.value || '');
            }
            if (glNameSel){
              const curNm = (glNameSel.value || glNameSel.getAttribute('data-orig') || '').trim();
              const esc2 = (s) => String(s).replace(/"/g,'&quot;').replace(/</g,'&lt;');
              if (curNm && !(curNm in glNameToNum)){
                glNameSel.innerHTML = `<option value="${esc2(curNm)}">${esc2(curNm)}</option>` + glNameOpts;
              } else {
                glNameSel.innerHTML = glNameOpts;
              }
              enhanceSearch(glNameSel);
              setSelectValue(glNameSel, curNm || glNameSel.value || '');
            }
            if (utilSel){
              const curU = (utilSel.value || utilSel.getAttribute('data-orig') || '').trim();
              const curUTitle = toTitle(curU);
              const parser = new DOMParser();
              const doc = parser.parseFromString(`<select>${utilOpts}</select>`, 'text/html');
              const hasCur = Array.from(doc.querySelectorAll('option')).some(o => (o.value||'').toLowerCase() === curUTitle.toLowerCase());
              utilSel.innerHTML = (curU && !hasCur ? `<option value="${curUTitle.replace(/"/g,'&quot;')}">${curUTitle.replace(/</g,'&lt;')}</option>` : '') + utilOpts;
              enhanceSearch(utilSel);
              setSelectValue(utilSel, curUTitle || utilSel.value || '');
            }
            if (hovSel){
              const esc2 = (s) => String(s).replace(/"/g,'&quot;').replace(/</g,'&lt;');
              const cur = (hovSel.value || hovSel.getAttribute('data-orig') || '').trim();
              const opts = ['','House','Vacant'];
              hovSel.innerHTML = opts.map(v => `<option value="${esc2(v)}">${esc2(v)}</option>`).join('');
              setSelectValue(hovSel, cur || '');
            }
            // Sync both ways
            if (glSel && glNameSel){
              const isVacantName = (s) => /\bvacant\b/i.test(String(s||''));
              const pickOptionByText = (sel, text) => {
                if (!sel || !text) return false;
                const t = String(text).trim().toLowerCase();
                const opt = Array.from(sel.options).find(o => (o.text||'').trim().toLowerCase() === t);
                if (opt){ setSelectValue(sel, opt.value); return true; }
                return false;
              };
              const syncFromNum = () => {
                const key = (glSel.value||'').trim();
                const nm = glNumToName[key];
                if (nm) setSelectValue(glNameSel, nm);
                // Also update GL ID hidden field for charge code mapping
                const idField = line.querySelector('input[name="EnrichedGLAccountID"]');
                const mappedId = (window._glNumToId||{})[key] || '';
                if (idField && mappedId) idField.value = mappedId;
                // House/Vacant follows GL Name: only 'Vacant' terms flip to Vacant
                const hov = line.querySelector('select[name="House Or Vacant"]');
                if (hov){ setSelectValue(hov, isVacantName(glNameSel.value||nm) ? 'Vacant' : 'House'); }
                saveDraft(line);
              };
              const syncFromName = () => {
                const nm = (glNameSel.value||'').trim();
                const num = glNameToNum[nm];
                if (num) setSelectValue(glSel, num);
                // Also update GL ID hidden field for charge code mapping
                const idField = line.querySelector('input[name="EnrichedGLAccountID"]');
                const mappedId = (window._glNumToId||{})[num] || '';
                if (idField && mappedId) idField.value = mappedId;
                const hov = line.querySelector('select[name="House Or Vacant"]');
                if (hov){ setSelectValue(hov, isVacantName(nm) ? 'Vacant' : 'House'); }
                saveDraft(line);
              };
              glSel.addEventListener('change', syncFromNum);
              glNameSel.addEventListener('change', syncFromName);
              if (glSel.value && !glNameSel.value) syncFromNum();
              if (glNameSel.value && !glSel.value) syncFromName();

              // When House/Vacant changes, gently steer GL Name, but only switch to Vacant names when Vacant selected
              const hovSel = line.querySelector('select[name="House Or Vacant"]');
              if (hovSel){
                const toTitle = (s) => String(s||'').toLowerCase().replace(/\b\w/g, c=>c.toUpperCase());
                const houseForVacant = {
                  'Vacant Electric': 'House Electric',
                  'Vacant Gas': 'Gas',
                  'Vacant Water': 'Water',
                  'Vacant Sewer': 'Sewer',
                  'Vacant Activation': ''
                };
                hovSel.addEventListener('change', () => {
                  const val = (hovSel.value||'').trim();
                  const curName = (glNameSel.value||'').trim();
                  if (val === 'Vacant'){
                    // Try to pick a Vacant GL aligned to current name or utility
                    const util = toTitle(line.querySelector('select[name="Utility Type"]')?.value || '');
                    const candidates = [
                      `Vacant ${util}`,
                      curName.replace(/^House\s+/i,'Vacant '),
                      curName.startsWith('Vacant ') ? curName : ''
                    ].filter(Boolean);
                    for (const c of candidates){ if (pickOptionByText(glNameSel, c)) { syncFromName(); return; } }
                    // Fallback: pick first Vacant* option available
                    const anyVac = Array.from(glNameSel.options).map(o=>o.text||'').find(t=>/\bvacant\b/i.test(t));
                    if (anyVac){ pickOptionByText(glNameSel, anyVac); syncFromName(); }
                  } else {
                    // House selected: if current is a Vacant* name, try to map back
                    if (isVacantName(curName)){
                      const mapped = houseForVacant[curName] || curName.replace(/^Vacant\s+/i,'').replace(/^Electric$/i,'House Electric');
                      if (mapped){ if (pickOptionByText(glNameSel, mapped)) { syncFromName(); return; } }
                    }
                    // Otherwise do not force change; keep non-vacant selection
                    saveDraft(line);
                  }
                });
              }
            }
            // When utility type changes, update GL Account based on House/Vacant + Utility
            if (utilSel){ utilSel.addEventListener('change', () => {
              try {
                const hv = line.querySelector('select[name="House Or Vacant"]');
                const hvVal = (hv?.value || hv?.getAttribute('data-orig') || 'HOUSE').toUpperCase();
                applyHVGL(line, hvVal);
              } catch(_) {}
              saveDraft(line);
            }); }
            if (hovSel){ hovSel.addEventListener('change', () => saveDraft(line)); }
          }

          // Initialize existing lines now
          document.querySelectorAll('.line').forEach(initLineSelects);
          // Expose initializer for dynamically added/duplicated lines
          window.initLineSelects = initLineSelects;
          // IMPORTANT: re-apply header and line drafts after options/Choices are in place
          try { if (typeof loadAllDraftsBatch === 'function') { loadAllDraftsBatch(); } } catch(_){ }
        }).catch(() => {
          // Fallback: build datalists from current page DOM values so user still sees choices
          const propList = document.getElementById('propList');
          const vendList = document.getElementById('vendList');
          const glList = document.getElementById('glList');
          const utilList = document.getElementById('utilList');
          const seen = new Set();
          function addOpt(list, val){ if (!list || !val) return; if (seen.has(list.id+val)) return; const o=document.createElement('option'); o.value = val; list.appendChild(o); seen.add(list.id+val); }
          const pn = document.getElementById('propName')?.value?.trim(); addOpt(propList, pn);
          const vn = document.getElementById('vendName')?.value?.trim(); addOpt(vendList, vn);
          document.querySelectorAll('input[name="EnrichedGLAccountNumber"]').forEach(i => addOpt(glList, i.value.trim()));
          document.querySelectorAll('input[name="Utility Type"]').forEach(i => addOpt(utilList, (i.value||'').trim().toUpperCase()));
          try{ console.log('[review] initOptions: done'); }catch(_){ }
          // After options are populated, re-apply drafts to ensure selects pick saved values
          try { if (typeof loadAllDraftsBatch === 'function') { loadAllDraftsBatch(); } } catch(_){ }
        })
        .catch(err => {
          try{ console.error('[review] initOptions failed', err); }catch(_){ }
        });
    }
    window.initOptions = initOptions;

    // --- Helpers for dynamically added lines ---
    function bindLineAutosave(line){
      if (!line) return;
      if (!debouncedSaves.has(line)) debouncedSaves.set(line, debounce(saveDraft, 250));
      const saver = debouncedSaves.get(line);
      line.querySelectorAll('input').forEach(inp => {
        inp.addEventListener('change', e => saver(e.target.closest('.line')));
        inp.addEventListener('input', e => saver(e.target.closest('.line')));
        // Update total when Line Item Charge changes
        if (inp.name === 'Line Item Charge'){
          inp.addEventListener('input', updateLineItemsTotal);
          inp.addEventListener('change', updateLineItemsTotal);
        }
      });
      line.querySelectorAll('select').forEach(sel => {
        sel.addEventListener('change', e => saver(e.target.closest('.line')));
      });
    }

    function renumberLines(){
      let n = 1;
      document.querySelectorAll('.line .line-num').forEach(el => { el.textContent = 'Line #' + (n++); });
    }

    // Calculate and update line items total
    function updateLineItemsTotal(){
      let total = 0;
      const lines = document.querySelectorAll('.line:not([data-deleted="1"])');
      lines.forEach(line => {
        const chargeInput = line.querySelector('input[name="Line Item Charge"]');
        if (chargeInput && chargeInput.value){
          const val = parseFloat(String(chargeInput.value).replace(/[^0-9.-]/g, ''));
          if (!isNaN(val)) total += val;
        }
      });
      const display = document.getElementById('lineItemsTotal');
      if (display){
        display.textContent = '$' + total.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
      }
    }

    // Force specific selects in a line to be native and interactive
    function forceNativeLineSelects(line){
      if (!line) return;
      const htmls = window._optHTML || {};
      const rebuild = (selectorName, html) => {
        try{
          // Always target the original hidden select, then remove its Choices wrapper sibling
          const oldSel = line.querySelector(`select[name="${selectorName}"]`);
          if (!oldSel) return null;
          let wrapper = null;
          // The Choices wrapper is typically the next sibling
          if (oldSel.nextElementSibling && oldSel.nextElementSibling.classList && oldSel.nextElementSibling.classList.contains('choices')){
            wrapper = oldSel.nextElementSibling;
          } else {
            // Fallback: search nearby
            wrapper = line.querySelector(`.choices ~ select[name="${selectorName}"]`) ? line.querySelector('.choices') : line.querySelector('.choices');
            if (wrapper && !wrapper.parentElement) wrapper = null;
          }
          const fresh = document.createElement('select');
          fresh.setAttribute('name', selectorName);
          fresh.innerHTML = html || '<option value=""></option>';
          try{ fresh.removeAttribute('hidden'); fresh.removeAttribute('data-search'); }catch(_){ }
          try{ fresh.disabled = false; fresh.readOnly = false; fresh.tabIndex = 0; }catch(_){ }
          // Insert fresh right before wrapper (if present) to keep layout stable, then remove both old pieces
          if (wrapper && wrapper.parentElement){ wrapper.parentElement.insertBefore(fresh, wrapper); }
          else { oldSel.parentElement && oldSel.parentElement.insertBefore(fresh, oldSel); }
          try{ oldSel.remove(); }catch(_){ }
          try{ wrapper && wrapper.remove(); }catch(_){ }
          return fresh;
        }catch(_){ return null; }
      };
      const numSel = rebuild('EnrichedGLAccountNumber', htmls.glOpts);
      const nameSel = rebuild('EnrichedGLAccountName', htmls.glNameOpts);
      const utilSel = rebuild('Utility Type', htmls.utilOpts);
      const saver = (ln => () => saveDraft(ln))(line);
      if (numSel) numSel.addEventListener('change', saver);
      if (nameSel) nameSel.addEventListener('change', saver);
      // When utility type changes, update GL Account based on House/Vacant + Utility
      if (utilSel) utilSel.addEventListener('change', () => {
        try {
          const hovSel = line.querySelector('select[name="House Or Vacant"]');
          const hvVal = (hovSel?.value || hovSel?.getAttribute('data-orig') || 'HOUSE').toUpperCase();
          applyHVGL(line, hvVal);
        } catch(_) {}
        saver();
      });
      setTimeout(() => { try{ line.querySelectorAll('.choices').forEach(x => x.remove()); }catch(_){ } }, 0);
    }

    // Create a new empty line based on first line structure
    function addLine(){
      const first = document.querySelector('.line');
      const container = document.getElementById('lines');
      if (!first || !container){ alert('No template line to duplicate.'); return; }
      const clone = first.cloneNode(true);
      clone.setAttribute('data-new','1');
      clone.removeAttribute('data-orig-id');
      clone.setAttribute('data-line-id', 'new-' + Date.now());
      // clear inputs (text and hidden - hidden inputs like EnrichedGLAccountID must be cleared to avoid inheriting old values)
      clone.querySelectorAll('input[type=text]').forEach(i => { i.value = ''; i.setAttribute('data-orig', ''); });
      clone.querySelectorAll('input[type=hidden]').forEach(i => { i.value = ''; i.setAttribute('data-orig', ''); });
      // clear readonly display divs inside .field (they show cloned values otherwise)
      clone.querySelectorAll('.field > div:not(.lbl)').forEach(d => {
        // Don't clear the label div, only the value display div
        if (!d.classList.contains('lbl') && !d.querySelector('input') && !d.querySelector('select')) {
          d.textContent = '';
        }
      });
      // reset picks
      const pick = clone.querySelector('.line-pick'); if (pick) pick.checked = false;
      // reset selects to empty and clear data-orig
      clone.querySelectorAll('select').forEach(s => { try { s.value=''; s.setAttribute('data-orig', ''); } catch(_) {} });
      // Remove any Choices.js wrappers from cloned line (we'll rebuild fresh)
      clone.querySelectorAll('.choices').forEach(c => c.remove());
      // mount
      container.appendChild(clone);
      // re-init selects with options and sync listeners (don't use forceNativeLineSelects - it breaks sync)
      if (window.initLineSelects) window.initLineSelects(clone);
      bindLineAutosave(clone);
      renumberLines();
      updateLineItemsTotal();
    }

    function duplicateSelectedLines(){
      const picks = getSelectedLines();
      if (!picks.length){ alert('Select at least one line to duplicate.'); return; }
      const container = document.getElementById('lines');
      picks.forEach(src => {
        // Capture current values from source BEFORE cloning (Choices.js may hide actual select value)
        const srcValues = {};
        ['EnrichedGLAccountNumber', 'EnrichedGLAccountName', 'Utility Type', 'House Or Vacant'].forEach(name => {
          const sel = src.querySelector(`select[name="${name}"]`);
          if (sel) srcValues[name] = sel.value || sel.getAttribute('data-orig') || '';
        });
        src.querySelectorAll('input[type="text"]').forEach(inp => {
          if (inp.name) srcValues[inp.name] = inp.value || '';
        });

        const dup = src.cloneNode(true);
        dup.setAttribute('data-new','1');
        dup.removeAttribute('data-orig-id');
        dup.setAttribute('data-line-id', 'new-' + Date.now() + '-' + Math.floor(Math.random()*1000));
        // keep values, but uncheck picker
        const pick = dup.querySelector('.line-pick'); if (pick) pick.checked = false;
        // Remove any Choices.js wrappers from cloned line (we'll rebuild fresh)
        dup.querySelectorAll('.choices').forEach(c => c.remove());
        container.appendChild(dup);
        // re-init selects with options and sync listeners (don't use forceNativeLineSelects - it breaks sync)
        if (window.initLineSelects) window.initLineSelects(dup);

        // Restore captured values AFTER rebuild
        Object.keys(srcValues).forEach(name => {
          const val = srcValues[name];
          if (!val) return;
          const sel = dup.querySelector(`select[name="${name}"]`);
          if (sel) { setSelectValue(sel, val); return; }
          const inp = dup.querySelector(`input[name="${name}"]`);
          if (inp) inp.value = val;
        });

        bindLineAutosave(dup);
      });
      renumberLines();
      updateLineItemsTotal();
      clearAllLineChecks();
    }

    // Reset selected lines to their original values (from data-orig)
    function resetSelected(){
      const picks = getSelectedLines();
      if (!picks.length){ alert('Select at least one line to reset.'); return; }
      picks.forEach(line => {
        // Un-delete if previously marked deleted
        if (line.hasAttribute('data-deleted')){
          line.removeAttribute('data-deleted');
          line.style.opacity = '';
        }
        // For inputs
        line.querySelectorAll('input[type=text]').forEach(inp => {
          if (inp.hasAttribute('data-orig')){
            inp.value = inp.getAttribute('data-orig') || '';
          }
        });
        // For selects (Choices-aware)
        line.querySelectorAll('select').forEach(sel => {
          const orig = sel.getAttribute('data-orig');
          if (orig != null){ setSelectValue(sel, orig); }
        });
        // Persist reset via autosave
        saveDraft(line);
      });
      updateLineItemsTotal();
      clearAllLineChecks();
    }

    // Delete selected lines: remove brand-new ones, mark existing originals as deleted
    function deleteSelectedLines(){
      const picks = getSelectedLines();
      if (!picks.length){ alert('Select at least one line to delete.'); return; }
      const container = document.getElementById('lines');
      picks.forEach(line => {
        if (line.hasAttribute('data-new')){
          // entirely remove brand-new, unsaved lines
          if (container) container.removeChild(line);
          return;
        }
        // mark original line as deleted and disable controls
        line.setAttribute('data-deleted','1');
        line.style.opacity = '0.5';
        line.querySelectorAll('input,select,button,textarea').forEach(el => { try{ el.disabled = true; }catch(_){ } });
        // persist deletion to draft for this line
        saveDraft(line);
      });
      renumberLines();
      updateLineItemsTotal();
      clearAllLineChecks();
    }

    // Fallback: if something stops the loadHeader->initOptions path, ensure catalogs still fetch
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => { if (!window._catalogsLoaded && !window._optionsInitStarted) try { initOptions(); } catch(_){} }, 800);
    });

    function getSelectedLines(){
      return Array.from(document.querySelectorAll('.line')).filter(l => l.querySelector('.line-pick')?.checked);
    }

    function clearAllLineChecks(){
      document.querySelectorAll('.line-pick').forEach(cb => { cb.checked = false; });
    }

    // Toggle minimize/expand for a line item
    function toggleMinimize(btn){
      try{
        const line = btn.closest('.line');
        if (!line) return;
        const isMinimized = line.getAttribute('data-minimized') === '1';
        if (isMinimized){
          line.removeAttribute('data-minimized');
          btn.textContent = 'Minimize';
        } else {
          line.setAttribute('data-minimized', '1');
          btn.textContent = 'Expand';
        }
      }catch(_){ }
    }

    // --- Header draft helpers (ensure defined before used) ---
    const headerBox = document.getElementById('headerBox');
    let lastHeaderSig = '';
    function collectHeader(){
      const fields = {};
      if (headerBox){
        headerBox.querySelectorAll('input').forEach(i => fields[i.name] = i.value);
        headerBox.querySelectorAll('select').forEach(s => fields[s.name] = s.value);
      }
      return fields;
    }
    async function saveHeader(){
      try{
        const payload = {
          pdf_id: document.querySelector('.line')?.getAttribute('data-pdf-id') || '',
          line_id: '__header__',
          date: dateVal,
          invoice: invoiceVal,
          fields: collectHeader()
        };
        const sig = JSON.stringify(payload.fields);
        if (sig === lastHeaderSig) return; // no change
        const resp = await fetch('/api/drafts', { method:'PUT', credentials: 'same-origin', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
        if (resp.ok) lastHeaderSig = sig;
      }catch(_){ }
    }

    async function manualSaveHeader(){
      const btn = document.getElementById('saveHeaderBtn');
      const status = document.getElementById('headerSaveStatus');
      try{
        btn.disabled = true;
        status.textContent = 'Saving...';
        status.style.color = '#666';
        const payload = {
          pdf_id: document.querySelector('.line')?.getAttribute('data-pdf-id') || '',
          line_id: '__header__',
          date: dateVal,
          invoice: invoiceVal,
          fields: collectHeader()
        };
        const resp = await fetch('/api/drafts', { method:'PUT', credentials: 'same-origin', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload)});
        if (resp.ok) {
          lastHeaderSig = JSON.stringify(payload.fields);
          status.textContent = 'Saved!';
          status.style.color = '#28a745';
          setTimeout(() => { status.textContent = ''; }, 2000);
        } else {
          status.textContent = 'Save failed';
          status.style.color = '#dc3545';
        }
      }catch(e){
        status.textContent = 'Error: ' + e.message;
        status.style.color = '#dc3545';
      }finally{
        btn.disabled = false;
      }
    }

    async function loadHeader(){
      const first = document.querySelector('.line');
      if (!first) return;
      const pdf_id = first.getAttribute('data-pdf-id');
      const r = await fetch(`/api/drafts?pdf_id=${encodeURIComponent(pdf_id)}&line_id=${encodeURIComponent('__header__')}`, { credentials: 'same-origin' });
      const j = await r.json();
      if (j && j.draft && j.draft.fields) {
        for (const [k,v] of Object.entries(j.draft.fields)) {
          const inp = headerBox.querySelector(`input[name="${k}"]`);
          // Map to actual view ids for vendor fields
          const viewId = (k === 'EnrichedVendorName') ? 'hdr_vendor_view'
                        : (k === 'EnrichedVendorID') ? 'hdr_vendorid_view'
                        : `hdr_${k.replaceAll(' ','_').toLowerCase()}_view`;
          const view = document.getElementById(viewId);
          if (inp && v != null && String(v).trim() !== '') inp.value = v;
          const sel = headerBox.querySelector(`select[name="${k}"]`);
          if (sel && v != null && String(v).trim() !== '') setSelectValue(sel, v);
          if (view && v != null && String(v).trim() !== '') view.textContent = v;
        }
        lastHeaderSig = JSON.stringify(j.draft.fields||{});
      }
    }
    headerBox.querySelectorAll('input').forEach(inp => { if (!inp.dataset.bound){ inp.addEventListener('change', saveHeader); inp.dataset.bound='1'; }});
    headerBox.querySelectorAll('select').forEach(sel => { if (!sel.dataset.bound){ sel.addEventListener('change', saveHeader); sel.dataset.bound='1'; }});
    // Defer options init until header draft is applied
    (async ()=>{ try { await loadHeader(); } finally { if (window.initOptions) window.initOptions(); } })();

    async function submitAll(ev){
      ev.preventDefault();
      const btn = document.getElementById('submitBtn');
      const form = document.getElementById('submitForm');
      const toast = document.getElementById('submitToast');
      const body = document.getElementById('toastBody');
      // Force-flush any pending draft changes to the server before computing ids/extras
      try { await saveAllDrafts(); } catch(_){ }
      const allOrigIds = [];
      const deletedIds = [];
      const boxes = Array.from(document.querySelectorAll('.line'));
      const total = boxes.length;
      const missing = [];
      const extras = [];
      boxes.forEach(b => {
        const oid = b.getAttribute('data-orig-id');
        if (oid){
          allOrigIds.push(oid);
          if (b.hasAttribute('data-deleted')) deletedIds.push(oid);
        } else if (b.hasAttribute('data-new')) {
          // collect new line fields - include text inputs, selects, and hidden inputs
          const obj = {};
          b.querySelectorAll('input[type=text]').forEach(i => { if (i.name) obj[i.name] = i.value; });
          b.querySelectorAll('input[type=hidden]').forEach(i => { if (i.name && i.value) obj[i.name] = i.value; });
          b.querySelectorAll('select').forEach(s => { if (s.name && s.value) obj[s.name] = s.value; });
          extras.push(obj);
        } else {
          // derive a friendly line label
          const numEl = b.querySelector('.line-num');
          const label = numEl ? numEl.textContent.trim() : (b.getAttribute('data-line-id') || 'unknown');
          missing.push(label);
        }
      });
      document.getElementById('idsField').value = allOrigIds.join('|||');
      // attach extras JSON as hidden field for submit
      let extrasField = document.getElementById('extrasField');
      if (!extrasField){ extrasField = document.createElement('input'); extrasField.type='hidden'; extrasField.name='extras'; extrasField.id='extrasField'; form.appendChild(extrasField); }
      extrasField.value = JSON.stringify(extras);
      // attach deleted_ids as separate hidden field for backend to update status but exclude from merged
      let delField = document.getElementById('deletedIdsField');
      if (!delField){ delField = document.createElement('input'); delField.type='hidden'; delField.name='deleted_ids'; delField.id='deletedIdsField'; form.appendChild(delField); }
      delField.value = deletedIds.join('|||');
      btn.disabled = true; btn.textContent = 'Submitting…';
      try{
        const fd = new FormData(form);
        const r = await fetch('/api/submit', { method:'POST', body: fd });
        const j = await r.json();
        if (r.ok && j && j.ok){
          const sent = Number(j.sent||0);
          let html = `<div class="ok"><strong>Submitted ${sent} of ${total} line(s).</strong></div>`;
          if (sent < total && missing.length){
            html += `<div class="err" style="margin-top:6px"><strong>Missing lines:</strong> ${missing.join(', ')}</div>`;
          }
          html += `<div style="margin-top:8px">Delta: <code>${j.delta_key}</code></div>
                   <div>Merged: <code>${j.merged_key}</code></div>
                   <div>Pre-Entrata: <code>${j.preentrata_key}</code></div>
                   <div id="liveStatus" class="muted" style="margin-top:10px">Redirecting to invoice list...</div>`;
          body.innerHTML = html;
          toast.classList.add('show');
          // Redirect to parent invoices page after 2.5 seconds
          setTimeout(() => {
            window.location.href = `/invoices?date=${encodeURIComponent(dateVal)}&cb=${Date.now()}`;
          }, 2500);

          // Auto-refresh the invoice status until COMPLETE (or timeout)
          const first = document.querySelector('.line');
          const targetPdfId = first ? first.getAttribute('data-pdf-id') : null;
          const statusEl = document.getElementById('liveStatus');
          if (targetPdfId && statusEl){
            const started = Date.now();
            const poll = async () => {
              try{
                const resp = await fetch(`/api/invoices_status?date=${encodeURIComponent(dateVal)}`);
                if (!resp.ok) return;
                const data = await resp.json();
                const hit = (data.invoices||[]).find(x => x.pdf_id === targetPdfId);
                if (hit){
                  statusEl.textContent = `Current status: ${hit.status}`;
                  if (hit.status === 'COMPLETE') return; // stop polling
                }
                if (Date.now() - started < 120000){
                  setTimeout(poll, 5000);
                } else {
                  statusEl.textContent = statusEl.textContent + ' (stopped auto-checking)';
                }
              }catch(_){ setTimeout(poll, 7000); }
            };
            setTimeout(poll, 3000);
          }
        } else {
          body.innerHTML = `<div class="err"><strong>Failed.</strong></div><pre style="white-space:pre-wrap">${(j && (j.error||JSON.stringify(j))) || 'Unknown error'}</pre>`;
          toast.classList.add('show');
        }
      }catch(e){
        body.innerHTML = `<div class="err"><strong>Error.</strong></div><pre style="white-space:pre-wrap">${e}</pre>`;
        toast.classList.add('show');
      } finally {
        btn.disabled = false; btn.textContent = 'Submit';
      }
      return false;
    }

    // --- Resizable PDF panel ---
    (function enableResizer(){
      const root = document.documentElement;
      const grid = document.querySelector('.row');
      const leftCard = grid ? grid.children[0] : null;
      const resizer = document.getElementById('resizer');
      if (!grid || !leftCard || !resizer) return;
      // restore saved width
      const saved = localStorage.getItem('review_leftW');
      if (saved) root.style.setProperty('--leftW', saved);
      let dragging = false; let startX = 0;
      resizer.addEventListener('mousedown', (e) => {
        dragging = true; startX = e.clientX; document.body.style.cursor = 'col-resize'; e.preventDefault();
      });
      window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        const rect = grid.getBoundingClientRect();
        const leftRect = leftCard.getBoundingClientRect();
        const minLeft = 320; // px
        const maxLeft = Math.max(600, rect.width - 600 - 40); // leave room for right min + gaps
        let newW = Math.min(maxLeft, Math.max(minLeft, leftRect.width + (e.clientX - startX)));
        root.style.setProperty('--leftW', newW + 'px');
        startX = e.clientX;
      });
      window.addEventListener('mouseup', () => {
        if (!dragging) return; dragging = false; document.body.style.cursor='';
        const val = getComputedStyle(root).getPropertyValue('--leftW').trim();
        localStorage.setItem('review_leftW', val);
      });
    })();

    // IMPROVE modal functionality
    (function(){
      function showImproveToast(msg, type){
        const t = document.getElementById('improveToast');
        t.textContent = msg;
        t.className = 'improve-toast ' + (type === 'ok' ? 'ok' : 'err');
        t.classList.add('show');
        setTimeout(() => t.classList.remove('show'), 2500);
      }

      const modal = document.getElementById('improveModal');
      const improveBtn = document.getElementById('improveBtn');
      const cancelBtn = document.getElementById('cancelReport');
      const submitBtn = document.getElementById('submitReport');
      const titleInput = document.getElementById('reportTitle');
      const descInput = document.getElementById('reportDesc');

      improveBtn.addEventListener('click', () => {
        modal.classList.add('show');
        titleInput.focus();
      });

      cancelBtn.addEventListener('click', () => {
        modal.classList.remove('show');
        titleInput.value = '';
        descInput.value = '';
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('show');
          titleInput.value = '';
          descInput.value = '';
        }
      });

      submitBtn.addEventListener('click', async () => {
        const title = titleInput.value.trim();
        const description = descInput.value.trim();

        if (!title || !description) {
          showImproveToast('Please fill in both title and description', 'err');
          return;
        }

        try {
          const response = await fetch('/api/debug/report', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
              title: title,
              description: description,
              page_url: window.location.href
            })
          });

          if (!response.ok) {
            throw new Error('Failed to submit report');
          }

          showImproveToast('Report submitted successfully', 'ok');
          modal.classList.remove('show');
          titleInput.value = '';
          descInput.value = '';
        } catch (e) {
          showImproveToast('Error submitting report', 'err');
        }
      });
    })();

    // -------- Invoice Timing Tracker --------
    (function(){
      // Get invoice ID from the first line's pdf_id or fall back to account+date
      const firstLine = document.querySelector('.line[data-pdf-id]');
      const invoiceId = firstLine ? firstLine.getAttribute('data-pdf-id') : '{{ account }}_{{ date }}';

      if (!invoiceId) {
        console.log('[TIMING] No invoice ID found, timing disabled');
        return;
      }

      let sessionStartTime = Date.now();
      let totalPreviousSeconds = 0;
      let heartbeatInterval = null;
      let displayInterval = null;

      // Format seconds as M:SS or H:MM:SS
      function formatTime(totalSeconds) {
        const hours = Math.floor(totalSeconds / 3600);
        const mins = Math.floor((totalSeconds % 3600) / 60);
        const secs = Math.floor(totalSeconds % 60);
        if (hours > 0) {
          return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      // Update the timer display
      function updateDisplay() {
        const currentSessionSeconds = Math.floor((Date.now() - sessionStartTime) / 1000);
        const totalSeconds = totalPreviousSeconds + currentSessionSeconds;
        const timerEl = document.getElementById('timerValue');
        if (timerEl) {
          timerEl.textContent = formatTime(totalSeconds);
        }
      }

      // Start timing session
      async function startTiming() {
        try {
          // First get existing timing to show accumulated time
          const getResp = await fetch(`/api/timing/${encodeURIComponent(invoiceId)}`, { credentials: 'same-origin' });
          if (getResp.ok) {
            const data = await getResp.json();
            totalPreviousSeconds = data.total_seconds || 0;
          }

          // Start the timing session
          await fetch(`/api/timing/${encodeURIComponent(invoiceId)}/start`, {
            method: 'POST',
            credentials: 'same-origin'
          });

          sessionStartTime = Date.now();
          updateDisplay();

          // Update display every second
          displayInterval = setInterval(updateDisplay, 1000);

          // Send heartbeat every 30 seconds
          heartbeatInterval = setInterval(async () => {
            try {
              await fetch(`/api/timing/${encodeURIComponent(invoiceId)}/heartbeat`, {
                method: 'POST',
                credentials: 'same-origin'
              });
            } catch (e) {
              console.log('[TIMING] Heartbeat failed:', e);
            }
          }, 30000);

          console.log('[TIMING] Started timing for invoice:', invoiceId);
        } catch (e) {
          console.log('[TIMING] Start failed:', e);
        }
      }

      // Stop timing session
      async function stopTiming() {
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        if (displayInterval) clearInterval(displayInterval);

        try {
          const resp = await fetch(`/api/timing/${encodeURIComponent(invoiceId)}/stop`, {
            method: 'POST',
            credentials: 'same-origin'
          });
          if (resp.ok) {
            const data = await resp.json();
            console.log('[TIMING] Stopped. Total minutes:', data.total_minutes);
          }
        } catch (e) {
          console.log('[TIMING] Stop failed:', e);
        }
      }

      // Start timing when page loads
      startTiming();

      // Stop timing when page unloads
      window.addEventListener('beforeunload', () => {
        // Use sendBeacon for reliable delivery during unload
        navigator.sendBeacon(`/api/timing/${encodeURIComponent(invoiceId)}/stop`);
      });

      // Also stop on visibility change (user switches tabs)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // Page is hidden - send heartbeat to save progress
          fetch(`/api/timing/${encodeURIComponent(invoiceId)}/heartbeat`, {
            method: 'POST',
            credentials: 'same-origin'
          }).catch(() => {});
        }
      });
    })();
  </script>

<!-- Datalists for dropdowns -->
<datalist id="propList"></datalist>
<datalist id="vendList"></datalist>
<datalist id="glList"></datalist>
<datalist id="utilList"></datalist>
</body>
</html>
